/******************************************************************/
/* CGI Wrapper Program to allow access to scripts on HTTPD server */
/* Written by:  Nathan Neulinger  <nneul@umr.edu>                 */
/* Includes many fixes and improvements as suggested by users     */
/******************************************************************/

#include "config.h"		/* Generated by Configure */
#include "cgiwrap.h"    /* Header File Includes */
#include "util.h"	/* Misc. Utility Routines and Defines */
#include "debug.h"	/* Prototypes for debuygging routines */

/* Debugging Trigger */
extern int CONF_DEBUG;

/***/
/**  Set limits of process resource consumption */
/***/
void SetLimits(void)
{
#if defined(CONF_USE_RLIMIT_CPU) && defined(RLIMIT_CPU)
	struct rlimit cpulim = { 9, 10 }; /* Set CPU timeout */
#endif

#if defined(CONF_USE_RLIMIT_VMEM) && defined(RLIMIT_VMEM)
	struct rimit vmemlim = { 2000000, 2500000 }; /* Set max VMEM */
#endif

#if defined(CONF_USE_RLIMIT_CPU) && defined(RLIMIT_CPU)
	DEBUG_Msg("\nSetting Limits (CPU)\n");
	setrlimit( RLIMIT_CPU, &cpulim );
#endif

#if defined(CONF_USE_RLIMIT_CPU) && defined(RLIMIT_VMEM)
	DEBUG_Msg("\nSetting Limits (VMEM)\n");
	setrlimit( RLIMIT_VMEM, &vmemlim );
#endif
}


/***/
/** Set any default signals needed
/***/
void SetSignals(void)
{
#if defined(SIGXCPU) && defined(HAS_SIGSET)
	DEBUG_Msg("\nSetting SIGXCPU to default behaviour\n");
	sigset(SIGXCPU, SIG_DFL);
#endif
}


/***/
/** Send a content-type header if it hasn't been already
/***/
void SendHeader(char *type)
{
	static int done = 0;
	
	if ( !done )
	{
		printf ("Content-Type: %s\n", type);
		done = 1;
	}
}


/***/
/**  Do an error message
/***/
void DoPError (char *msg)
{
	SendHeader("text/plain");
	printf("\n");

        printf("CGIwrap Error: %s \n", msg);
	printf("Error: ");
	MyPError();
	printf("\n");

        exit(1);
}


/***/
/**  Do an error message
/***/
void DoError (char *msg)
{
	SendHeader("text/plain");
	printf("\n");

        printf("CGIwrap Error: %s \n", msg);
        exit(1);
}



/***/
/**   Log a request to the log file. */
/***/
void Log (char *user, char *script, char *msg)
{

	time_t timevar;
	FILE *logFile;

	DEBUG_Msg("   Opening log file.");

	if ( (logFile = fopen(CONF_LOGFILE, "a")) == NULL )
	{
		DoPError("Could not open log file for appending!");
		exit(1);
	}

	DEBUG_Msg("   Writing log entry.");

	fprintf(logFile, "%s\t", NullCheck( user ) );
	fprintf(logFile, "%s\t", NullCheck( script ) );
	fprintf(logFile, "%s\t", NullCheck( getenv("REMOTE_HOST") ) );
	fprintf(logFile, "%s\t", NullCheck( getenv("REMOTE_ADDR") ) );
	fprintf(logFile, "%s\t", NullCheck( getenv("REMOTE_USER") ) );
	fprintf(logFile, "%s\t", NullCheck( msg ) );

	time(&timevar);
	fprintf(logFile, "%s", ctime(&timevar) );

	DEBUG_Msg("   Closing log file.");
	fclose(logFile);

	DEBUG_Msg("   Done logging request.");

}





/***/
/**   Extract and return the value portion of a key=value pair found in a string */
/***/
char *GetValue( char *keyword, char *string )
{
	char *returnStr;
	char *dataStr;
	char *tempStr;
	char *theString;
	int i;

	theString = mystrcpy(string);

	returnStr = (char *) 0;
	tempStr = (char *) strtok(theString, "&");
	while (tempStr)
	{
		dataStr = (char *) strstr(tempStr, keyword);
		if ( dataStr == tempStr )
		{
			returnStr = (char *) strchr (dataStr, '=') + 1;
			tempStr = (char *) 0;
		}
		else
		{
			tempStr = (char *) strtok( (char *) 0, "&");
		}
	}


	DEBUG_Str("   Keyword: ", keyword);
	DEBUG_Str("   Value: ", returnStr);

	returnStr = mystrcpy(returnStr);
	free(theString);
	return returnStr;
}



/***/
/**   Extract name and script from PathInfo */
/***/
void ExtractPathInfo(char **userStr, char **scrStr )
{
	char *dataStr;
	char *tempStr;
	char *pathStr;
	char *buf;
	static char putEnvString[500]; /* for PATH_INFO */
	static char putEnvString2[500]; /* for SCRIPT_NAME */

	int i;

	pathStr = mystrcpy( (char *) getenv("PATH_INFO"));
	tempStr = mystrcpy(pathStr);

	*userStr = (char *) strtok(tempStr, "/"); /* Get usestring */
	*scrStr = (char *) strtok( (char *) 0, "/"); /* Get script string */

	tempStr = (char *) strtok( (char *) 0, "/");

	tempStr = pathStr + strlen(*userStr) + strlen(*scrStr) + 2;
	strcpy(pathStr, tempStr ? tempStr : "");

	if (*userStr)
	{
		if (*userStr[0] == '~')
		{
			(*userStr)++;
		}
	}
	
	DEBUG_Msg("Extracted Data:");
	DEBUG_Str("   User: ", *userStr);
	DEBUG_Str("   Script: ", *scrStr);

	DEBUG_Msg("\nStripping user and script data from PATH_INFO env. var.");
	sprintf(putEnvString, "%s=%s", "PATH_INFO", pathStr);
	putenv(putEnvString);

	DEBUG_Msg("Adding user and script to SCRIPT_NAME env. var.");

       buf = (char*) malloc (strlen(getenv("SCRIPT_NAME"))
			+strlen(*userStr)+strlen(*scrStr)+3);
       if( !buf )
       {
           DoPError("Couldn't malloc memory for SCRIPT_NAME buf!");
       }

       sprintf(buf, "%s/%s/%s", getenv("SCRIPT_NAME"), *userStr, *scrStr);
       sprintf(putEnvString2, "%s=%s", "SCRIPT_NAME", buf);
       putenv(putEnvString2);
       free(buf);
}





/***/
/**  Clean up a username and script name - removing non printables and whitespace  */
/***/
char *Sanitize(char *string)
{
	int len, in;

	len = strlen(string);
	if (string) 
	{
		for (in=0; in<len; in++)
		{

			if ( !isprint(string[in]) || isspace(string[in]) )
			{
				string[in] = '_'; 
			}

#if defined(CONF_NOSUBDIRS)
			if ( string[in] == '/' ) 
			{
				string[in] = '_';
			}
#endif
		}

	}

	return string;
}




/***/
/**   Main program */
/***/
void main (int argc, char *argv[])
{
	char *userStr; /* User name */
	char *scrStr; /* Name of script */
	struct passwd *user; /* For getting uid from name */
	char *dir; /* For checking current directory */
	struct stat fileStat; /* For checking file status */
	int statErr; /* For checking reason why stat failed */
	int scriptErr; /* Return code from executing script */
	char *execStr; /* String that is actually executed */
	char *homeDir;
	char *curDir;
	char tempErrString[255];
	char *pathInfoString;
	char *queryString;
	char *olduserStr;
	char *oldscrStr;

	int validRequest;
	int debugExtLen;
	int cmdLen;
	int tempLength;

/* Start with debugging off */
	CONF_DEBUG = 0;

/* Determine if debugging output should be done */
	cmdLen = strlen(argv[0]);
	
	if ( cmdLen >= 1 )	
	{
		tempLength = cmdLen - 1;
		CONF_DEBUG = !strcmp(argv[0]+tempLength, "d");
	}	


	if ( !strncmp(argv[0], "nph-", 4) )
	{
		DEBUG_Msg("HTTP/1.0 200 Ok");
	}
	if ( CONF_DEBUG )
	{
		SendHeader("text/plain");
		printf("\n");
	}


/* Redirect stderr to stdout */
#if defined(CONF_REDIR_STDERR)
	DEBUG_Msg("\nRedirecting STDERR to STDOUT");
	dup2(1,2);
#endif


/* Check who is running this script */
#if defined(CONF_CHECK_HTTPD_USER)
	if ( !(user = getpwnam(CONF_HTTPD_USER)) )
	{
		DoError("CONF_HTTPD_USER not found.");
	}
	else
	{
		if ( getuid() != user->pw_uid )
		{
			DoError("Real UID does not match CONF_HTTPD_USER.");
		}
	}
#endif


	/* Set any default signal behavior */
	SetSignals();

	/* Set CPU and other limits */
	SetLimits();

	/***/
	/**   Print out the URL used to query this script */
	/***/
	DEBUG_Msg("Environment Variables:");
	DEBUG_Str("   QUERY_STRING:", (char *) getenv("QUERY_STRING") );
	DEBUG_Str("   PATH_INFO:", (char *) getenv("PATH_INFO") );
	DEBUG_Str("   REMOTE_HOST:", (char *) getenv("REMOTE_HOST") );
	DEBUG_Str("   REMOTE_ADDR:", (char *) getenv("REMOTE_ADDR") );
	DEBUG_Str("   SCRIPT_NAME:", (char *) getenv("SCRIPT_NAME") );
	

	validRequest = 0;
	pathInfoString = getenv("PATH_INFO");
	if ( pathInfoString )  /* use PATH_INFO */
	{
		if ( pathInfoString[0] != 0 )
		{
			DEBUG_Msg("\nTrying to extract user/script from PATH_INFO\n");
			ExtractPathInfo(&userStr, &scrStr);		
		
			validRequest = userStr && scrStr;
		}
		else
		{
			DEBUG_Msg("\nPATH_INFO is empty, can't check.\n");
		}
	}
	
	queryString = getenv("QUERY_STRING");
	if ( !validRequest && queryString )  /* or use QUERY_STRING */
	{
		if ( queryString[0] != 0 )
		{
			DEBUG_Msg("\nTrying to extract user/script from QUERY_STRING\n");		

			DEBUG_Msg("\nRead in user keyword value");
			userStr = GetValue("user", getenv("QUERY_STRING") );
	
			DEBUG_Msg("\nRead in script keyword value");
			scrStr = GetValue("script", getenv("QUERY_STRING") );

			validRequest = userStr && scrStr;
		}
		else
		{
			DEBUG_Msg("\nQUERY_STRING is empty, can't check.\n");
		}
	}
	
	
	if ( !validRequest ) /* nothing at all found */
	{
		DoError("Couldn't find user and script name, check your URL.");
	}

	DEBUG_Msg("\nModified Environment Variables:");
	DEBUG_Str("   PATH_INFO:", (char *) getenv("PATH_INFO") );
	DEBUG_Str("   SCRIPT_NAME:", (char *) getenv("SCRIPT_NAME") );
	
	/***/
	/**   Sanitize user name and script name */
	/***/

	olduserStr = mystrcpy(userStr);
	oldscrStr = mystrcpy(scrStr);
	DEBUG_StrStr("\nSanitize user name:", olduserStr, Sanitize(userStr));
	DEBUG_StrStr("Sanitize script name:", oldscrStr, Sanitize(scrStr));


	/***/
	/**  Restrict users or allow users based on file containing */
	/**  list of userids, or on NIS group */
	/***/
	if ( ! CheckAllowUser(userStr) )
	{
		Log(userStr, scrStr, "not in allow config");
		DoError("User not in allow config.");
	}

	if ( CheckDenyUser(userStr) )
	{
		Log(userStr, scrStr, "user in deny config");
		DoError("User in deny config.");
	}
		


	/***/
	/**   Log the query request to the log file */
	/***/
#if defined(CONF_LOG_REQUESTS)
	DEBUG_Msg("\nLog Request");
	Log(userStr, scrStr, "ok");
#endif 


	/***/
	/**   Lookup username to get UID */
	/***/
	if ( !(user = getpwnam(userStr)) )
	{
		DoError("User not found.");
	}

	homeDir = mystrcpy(user->pw_dir);

	DEBUG_Msg("\nUser Data Retrieved:");
	DEBUG_Str("   UserName:", user->pw_name);
	DEBUG_Int("   UID:", user->pw_uid);
	DEBUG_Int("   GID:", user->pw_gid);
	DEBUG_Str("   Directory:", homeDir);


	/***/
	/**   Change appropriate auxilliary groups */
	/***/

#if defined(HAS_SETGROUPS)
	if ( setgroups(0, NULL) == -1 )
		DoPError("setgroups() failed!");
#endif

#if defined(HAS_INITGROUPS) & defined(CONF_SETGROUPS)
	if ( initgroups( user->pw_name, user->pw_gid ) == -1 )
		DoPError("initgroups() failed!");
#endif


	/***/
	/**   Change real&effective UIDs to match username and group of that user */
	/***/
	ChangeID(user->pw_uid, user->pw_gid);

	/***/
	/**   Change to home directory of that user */
	/***/
	if ( chdir( homeDir ) )
	{
		DoPError("Could not chdir to home directory!");
	}




	/***/
	/**   Change to script directory */
	/***/
	if ( chdir( CONF_CGIDIR ) )
	{
		DoPError("Could not chdir to script directory!");
	}

	curDir = (char *) getcwd(0,200);
	DEBUG_Str("\nCurrent Directory: ", curDir );


	/***/
	/**   Do a stat or something on the script to execute to make sure it is */
	/**   Owned by person who is specified as the username, will prevent */
	/**   sym links to other people scripts */
	/***/

	if ( statErr = stat(scrStr, &fileStat) ) 
	{
		DoPError("Could not stat script file!");
	}

	DEBUG_Msg("\nResults of stat:");
	DEBUG_Int("   File Owner:", (int) fileStat.st_uid);
	DEBUG_Int("   File Group:", (int) fileStat.st_gid); 


#if defined(CONF_CHECK_SCRUID)
	if (fileStat.st_uid != user->pw_uid) 
	{
		DoError("Script does not have same UID");
	}
#endif


#if defined(CONF_CHECK_SCRGID)
	if (fileStat.st_gid != user->pw_gid)
	{
		DoError("Script does not have same GID");
	}
#endif


#if defined(CONF_CHECK_SCRSUID)
	if (fileStat.st_mode & S_ISUID)
	{
		DoError("Script is SUID - Will not Execute!");
	}
#endif


#if defined(CONF_CHECK_SCRSGID)
	if (fileStat.st_mode & S_ISGID)
	{
		DoError("Script is SGID - Will not Execute!");
	}
#endif

	/***/
	/**   Make sure the script is executable. */
	/***/
 
#if defined(CONF_CHECK_SCRMODE)
	if (!(fileStat.st_mode & S_IXUSR))
	{
		sprintf(tempErrString, "Script is not executable. Issue chmod 755 %s", scrStr);
		DoError(tempErrString);
	}
#endif


	/***/
	/**   Prepend "./" onto the script string so it can be executed without */
	/**   the current path affecting anything */
	/***/
	execStr = (char *) malloc( (size_t) (strlen(scrStr) + 2) );
	strcpy(execStr, "./");
	strcat(execStr, scrStr);



#if defined(CONF_AFS_SETPAG)
	DEBUG_Msg("\nSetting AFS PAG");
	setpag();
#endif


	DEBUG_Str("\n   Exec String: ", execStr);
	DEBUG_Msg("\n\nOutput of script follows:");
	DEBUG_Msg("=====================================================");

	/***/
	/**   Exec the script 
	/***/

#if defined(CONF_USE_SYSTEM)
#if defined(HAS_SYSTEM)
	scriptErr = system(execStr);
#else
	DoError("system() call not available");
#endif
#else
	scriptErr = execv(execStr, argv);   
#endif

}
